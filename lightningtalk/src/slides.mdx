import arex from '../assets/arex.jpg';

# Julia, GCP Cloud Run and Dash
## Julia、GCP Cloud RunでDash 

---

# These slides are at Connpass. So you can check them out.
## スライドはConnpassにアップされています。 是非みてください。

---

# Who am I?
## お前誰?

---

# My name is Alex, and I'm from Canada 🇨🇦
## アレックスで、カナダから来ました。

---

<Layout>
  <Fill style={{ margin: "auto" }}>
    <Heading size={3}>My username on Connpass is "globophobe".</Heading>
    <Heading size={4}>Connpassのユーザ名は「globophobe」です。</Heading>
  </Fill>
  <Fill>
    <Image style={{ borderRadius: "35px", marginLeft: "1em" }} src={arex} />
  </Fill>
</Layout>

---

# I make stuff with Python, Django, Vue.js and React Native. 
## PythonやDjangoやVue.jsやReact Nativeでプログラミングしています。

---

# I have been interested in Julia for a long time.
## 

---

# However, I am only just starting.
#

---

# What is Dash?
##

---

# It's a framework for building interactive web dashboards, particulary for data science.

---

# It's made by Plotly, a Canadian IT company, which is famous for plotly.js
##

---

# There is a very nice <a href="https://dash-gallery.plotly.host/Portal/">gallery of sample apps</a>.

---

# Both Python and R are officially supported. 

---

# Basically, you write Python or R and get an web app with Plotly.js and React.js

---

# However, no JavaScript need be written.

---

# In the case of Python, the web server is Flask.
##

---

# Looking at <a href="https://github.com/plotly/dashR">dashR</a>, the Github repository for the R integration...
##

---

# ...there seems to only be about 3000 lines of R code...
##

---

# ...mostly related to the "fiery" server for R.

---

# Obviously, Julia should also be supported.
#

---

# Last October, @waralex announced [Dashboards.jl](https://github.com/waralex/Dashboards.jl) at [discourse.julialang.org](https://discourse.julialang.org/t/developing-julia-interface-for-plotly-dash/30533/).
##

---

# Dashboards.jl uses HTTP.jl
#

---

# Currently, there are about 2000 lines of Julia code.
#

---

# In the Python universe, there is Dash, Bokeh, Streamlit, and Voila.
##  

---

# What's different?
#

<Table>
  <TableHeader>
    <TableHeaderItem></TableHeaderItem>
    <TableHeaderItem>Dash</TableHeaderItem>
    <TableHeaderItem>Bokeh</TableHeaderItem>
    <TableHeaderItem>Streamlit</TableHeaderItem>
    <TableHeaderItem>Voila</TableHeaderItem>
  </TableHeader>
  <TableBody>
    <TableRow>
      <TableItem>Tornado WebSockets</TableItem>
      <TableItem>❌</TableItem>
      <TableItem>✔️</TableItem>
      <TableItem>✔️</TableItem>
      <TableItem>✔️</TableItem>
    </TableRow>
    <TableRow>
      <TableItem>Serverless Environment</TableItem>
      <TableItem>✔️</TableItem>
      <TableItem>❌</TableItem>
      <TableItem>❌</TableItem>
      <TableItem>❌</TableItem>
    </TableRow>
    <TableRow>
      <TableItem>Julia</TableItem>
      <TableItem>✔️</TableItem>
      <TableItem>❌</TableItem>
      <TableItem>❌</TableItem>
      <TableItem>❌</TableItem>
    </TableRow>
  </TableBody>
</Table>

---

# There are interesting points about all of them. 
## 

---

# However, Dash is great because it can be used in a serverless environment...
#

---

# ...and supports multiple programming languages.
##

---

# There is a caveat, though.
#

---

# The state of a Dash app is stored on the client.
#

---

# This means that "when our Dash app UI changes, the state of your app..." 
##

---

# "...makes a round-trip to your...code, but is never saved on the server."

---

# This means "multiple servers can easily power the same Dash app..." 

---

# "...because the state does not need to be shared across servers."

---

# As the following, multiple fiery server processes serve multiple clients.
#

---

# As client state is never saved on the server, any one of the clients can connect to any one of the server processes.
#

---

# For serverless deployment, there are 2 possibilities:
#

---

# 1) AWS Lambda, Google Cloud Functions, etc.
#

---

# 2) Docker container, i.e. Google Cloud Run.
#

---

# Of the 2 choices, I think Google Cloud run could be better.
#

---

# The reason because there are stronger assurances that clients... 
#

---

# will connect to the same process, rather than invoking a new instance of a serverless function.
#

---

# In this way, initial data can be loaded into the server process...
#

---

# with stronger assurances that it will be reused between requests.
#

---
