import arex from '../assets/arex.jpg';

# Julia, GCP Cloud Run and Dash
## Juliaã€GCP Cloud Runã§Dash 

---

# These slides are at Connpass. So you can check them out.
## ã‚¹ãƒ©ã‚¤ãƒ‰ã¯Connpassã«ã‚¢ãƒƒãƒ—ã•ã‚Œã¦ã„ã¾ã™ã€‚ æ˜¯éã¿ã¦ãã ã•ã„ã€‚

---

# Who am I?
## ãŠå‰èª°?

---

# My name is Alex, and I'm from Canada ğŸ‡¨ğŸ‡¦
## ã‚¢ãƒ¬ãƒƒã‚¯ã‚¹ã§ã€ã‚«ãƒŠãƒ€ã‹ã‚‰æ¥ã¾ã—ãŸã€‚

---

<Layout>
  <Fill style={{ margin: "auto" }}>
    <Heading size={3}>My username on Connpass is "globophobe".</Heading>
    <Heading size={4}>Connpassã®ãƒ¦ãƒ¼ã‚¶åã¯ã€Œglobophobeã€ã§ã™ã€‚</Heading>
  </Fill>
  <Fill>
    <Image style={{ borderRadius: "35px", marginLeft: "1em" }} src={arex} />
  </Fill>
</Layout>

---

# I make stuff with Python, Django, Vue.js and React Native. 
## Pythonã‚„Djangoã‚„Vue.jsã‚„React Nativeã§ãƒ—ãƒ­ã‚°ãƒ©ãƒŸãƒ³ã‚°ã—ã¦ã„ã¾ã™ã€‚

---

# I have been interested in Julia for a long time.
## 

---

# However, I am only just starting.
#

---

# What is Dash?
##

---

# It's a framework for building interactive web dashboards, particulary for data science.

---

# It's made by Plotly, a Canadian IT company, which is famous for plotly.js
##

---

# There is a very nice <a href="https://dash-gallery.plotly.host/Portal/">gallery of sample apps</a>.

---

# Both Python and R are officially supported. 

---

# Basically, you write Python or R and get an web app with Plotly.js and React.js

---

# However, no JavaScript need be written.

---

# In the case of Python, the web server is Flask.
##

---

# Looking at <a href="https://github.com/plotly/dashR">dashR</a>, the Github repository for the R integration...
##

---

# ...there seems to only be about 3000 lines of R code...
##

---

# ...mostly related to the "fiery" server for R.

---

# Obviously, Julia should also be supported.
#

---

# Last October, @waralex announced [Dashboards.jl](https://github.com/waralex/Dashboards.jl) at [discourse.julialang.org](https://discourse.julialang.org/t/developing-julia-interface-for-plotly-dash/30533/).
##

---

# Dashboards.jl uses HTTP.jl
#

---

# Currently, there are about 2000 lines of Julia code.
#

---

# In the Python universe, there is Dash, Bokeh, Streamlit, and Voila.
##  

---

# What's different?
#

<Table>
  <TableHeader>
    <TableHeaderItem></TableHeaderItem>
    <TableHeaderItem>Dash</TableHeaderItem>
    <TableHeaderItem>Bokeh</TableHeaderItem>
    <TableHeaderItem>Streamlit</TableHeaderItem>
    <TableHeaderItem>Voila</TableHeaderItem>
  </TableHeader>
  <TableBody>
    <TableRow>
      <TableItem>Tornado WebSockets</TableItem>
      <TableItem>âŒ</TableItem>
      <TableItem>âœ”ï¸</TableItem>
      <TableItem>âœ”ï¸</TableItem>
      <TableItem>âœ”ï¸</TableItem>
    </TableRow>
    <TableRow>
      <TableItem>Serverless Environment</TableItem>
      <TableItem>âœ”ï¸</TableItem>
      <TableItem>âŒ</TableItem>
      <TableItem>âŒ</TableItem>
      <TableItem>âŒ</TableItem>
    </TableRow>
    <TableRow>
      <TableItem>Julia</TableItem>
      <TableItem>âœ”ï¸</TableItem>
      <TableItem>âŒ</TableItem>
      <TableItem>âŒ</TableItem>
      <TableItem>âŒ</TableItem>
    </TableRow>
  </TableBody>
</Table>

---

# There are interesting points about all of them. 
## 

---

# However, Dash is great because it can be used in a serverless environment...
#

---

# ...and supports multiple programming languages.
##

---

# There is a caveat, though.
#

---

# The state of a Dash app is stored on the client.
#

---

# This means that "when our Dash app UI changes, the state of your app..." 
##

---

# "...makes a round-trip to your...code, but is never saved on the server."

---

# This means "multiple servers can easily power the same Dash app..." 

---

# "...because the state does not need to be shared across servers."

---

# As the following, multiple fiery server processes serve multiple clients.
#

---

# As client state is never saved on the server, any one of the clients can connect to any one of the server processes.
#

---

# For serverless deployment, there are 2 possibilities:
#

---

# 1) AWS Lambda, Google Cloud Functions, etc.
#

---

# 2) Docker container, i.e. Google Cloud Run.
#

---

# Of the 2 choices, I think Google Cloud run could be better.
#

---

# The reason because there are stronger assurances that clients... 
#

---

# will connect to the same process, rather than invoking a new instance of a serverless function.
#

---

# In this way, initial data can be loaded into the server process...
#

---

# with stronger assurances that it will be reused between requests.
#

---
